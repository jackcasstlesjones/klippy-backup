#!/usr/bin/env python3

import re
import os
import json
import argparse
import shutil
from datetime import datetime

# Define default paths and settings
CONFIG_DIR = os.path.expanduser('~/.config/klippy')
CONFIG_FILE = os.path.join(CONFIG_DIR, 'config.json')
OLD_CONFIG_FILE = os.path.expanduser('~/.klippy_config.json')
print(f"Config file path: {CONFIG_FILE}")
DEFAULT_CONFIG = {
    'device_name': 'Kindle',
    'dest_dir': os.path.expanduser('~/obsidian/jacks-vault/clippings'),
    'moc_filename': 'moc-clippings'  # Without .md extension for consistency with link format
}

# Load configuration
def load_config():
    print(f"Loading config from: {CONFIG_FILE}")
    
    # Check if we need to migrate from old location
    if not os.path.exists(CONFIG_FILE) and os.path.exists(OLD_CONFIG_FILE):
        try:
            print(f"Migrating config from old location: {OLD_CONFIG_FILE}")
            # Ensure the config directory exists
            os.makedirs(CONFIG_DIR, exist_ok=True)
            
            # Read old config
            with open(OLD_CONFIG_FILE, 'r') as old_f:
                old_config = json.load(old_f)
            
            # Write to new location
            with open(CONFIG_FILE, 'w') as new_f:
                json.dump(old_config, new_f, indent=4, sort_keys=True)
                
            print(f"Successfully migrated config to: {CONFIG_FILE}")
        except Exception as e:
            print(f"Error migrating config: {str(e)}")
    
    # Now load from the new location
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                user_config = json.load(f)
                print(f"Loaded config: {user_config}")
                return user_config
        except json.JSONDecodeError:
            print(f"Error reading config file. Using empty configuration.")
            return {}
    else:
        print(f"Config file does not exist yet. Will be created when saving.")
    return {}

# Save configuration
def save_config(config):
    # Ensure we're only saving valid config keys
    valid_config = {k: config[k] for k in DEFAULT_CONFIG.keys() if k in config}
    
    print(f"Saving configuration: {valid_config}")
    print(f"Writing to file: {CONFIG_FILE}")
    
    # Ensure the config directory exists
    os.makedirs(CONFIG_DIR, exist_ok=True)
    
    # Debug: Check if file exists and is writable
    if os.path.exists(CONFIG_FILE):
        print(f"File exists. Current permissions: {oct(os.stat(CONFIG_FILE).st_mode)}")
    
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(valid_config, f, indent=4, sort_keys=True)
            f.flush()
            os.fsync(f.fileno())  # Force write to disk
        print(f"Configuration saved to {CONFIG_FILE}")
        
        # Verify the file was actually written
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                saved_config = json.load(f)
            print(f"Verification - File contains: {saved_config}")
        else:
            print(f"ERROR: File does not exist after save!")
    except Exception as e:
        print(f"ERROR saving configuration: {str(e)}")

# Setup configuration interactively
def setup_config():
    config = load_config()
    
    print("Klippy Configuration Setup")
    print("=========================")
    
    # Only show the current config values in the prompt, no defaults
    device_name = input(f"Enter device name [{config.get('device_name', '')}]: ")
    # Always update the config, even if the user just pressed Enter (use the current value)
    config['device_name'] = device_name if device_name else config.get('device_name', '')
    
    dest_dir = input(f"Enter destination directory [{config.get('dest_dir', '')}]: ")
    if dest_dir:
        # If the path is relative (doesn't start with /), make it absolute from current directory
        if not dest_dir.startswith('/') and not dest_dir.startswith('~'):
            dest_dir = os.path.join(os.getcwd(), dest_dir)
        config['dest_dir'] = os.path.expanduser(dest_dir)
    
    moc_filename = input(f"Enter MOC filename (without extension) [{config.get('moc_filename', '')}]: ")
    # Always update the config, even if the user just pressed Enter (use the current value)
    config['moc_filename'] = moc_filename if moc_filename else config.get('moc_filename', '')
    
    save_config(config)
    return config

# Get clippings file path based on device name
def get_clippings_file_path(device_name):
    return os.path.expanduser(f'~/../../Volumes/{device_name}/documents/My Clippings.txt')

# Ensure destination directory exists
def ensure_dest_dir(dest_dir):
    os.makedirs(dest_dir, exist_ok=True)

# Read the content of the clippings.txt file
def read_clippings(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8-sig') as file:
            return file.read()
    except UnicodeDecodeError:
        with open(file_path, 'r', encoding='latin-1') as file:
            return file.read()

# Parse the clippings into a structured format
def parse_clippings(content):
    clippings = {}
    entries = content.split('==========')

    for entry in entries:
        entry = entry.strip()
        if not entry:
            continue

        lines = entry.split('\n')
        if len(lines) < 3:
            continue

        book_line = lines[0].strip().lstrip("\ufeff")  # Strip BOM if present
        location_line = lines[1].strip() if len(lines) > 1 else ""
        quote = '\n'.join(lines[2:]).strip() if len(lines) > 2 else ""

        # Extract book title and author
        book_match = re.search(r'^(.*?)(?:\((.*?)\))?$', book_line)
        if book_match:
            book_title = book_match.group(1).strip()
            page_number = ""

            # Extract page or location number
            page_match = re.search(r'page (\d+)', location_line)
            if page_match:
                page_number = page_match.group(1)
            else:
                loc_match = re.search(r'location (\d+)', location_line)
                if loc_match:
                    page_number = f"loc {loc_match.group(1)}"

            if book_title and quote:
                # Ensure each book has a unique set of quotes
                if book_title not in clippings:
                    clippings[book_title] = set()

                clippings[book_title].add((page_number, quote))

    print(f"Found {sum(len(qs) for qs in clippings.values())} unique clippings across {len(clippings)} books.")
    return clippings

# Create markdown file for each book
def create_markdown_files(clippings, dest_dir, moc_filename):
    filenames = {}

    print(f"Creating markdown files for {len(clippings)} books")
    for book, quotes in clippings.items():
        clean_book_name = re.sub(r'[:\\/?*"><|]', '', book).strip()
        filename = f"{clean_book_name}.md"
        filepath = os.path.join(dest_dir, filename)
        filenames[book] = clean_book_name

        # Sort quotes by page/location number (if available)
        sorted_quotes = sorted(quotes, key=lambda q: q[0] if q[0] else "")

        print(f"Writing {len(sorted_quotes)} unique clippings to {repr(filepath)}")
        with open(filepath, 'w', encoding='utf-8') as md_file:  # 'w' mode overwrites existing files
            md_file.write(f"[[{moc_filename}]]\n\n")
            md_file.write(f"# {book}\n\n")

            for page, quote in sorted_quotes:
                if page:
                    md_file.write(f"**Page {page}**\n\n")
                else:
                    md_file.write("**Unknown location**\n\n")
                md_file.write(f"> {quote}\n\n")

    create_moc_file(filenames, dest_dir, moc_filename)
    return filenames

# Create a Map of Content (MOC) file
def create_moc_file(filenames, dest_dir, moc_filename):
    moc_filepath = os.path.join(dest_dir, f"{moc_filename}.md")

    print(f"Creating MOC file at {repr(moc_filepath)}")
    with open(moc_filepath, 'w', encoding='utf-8') as moc_file:
        moc_file.write("[[home]]\n\n")
        current_date = datetime.now().strftime("%Y-%m-%d")
        moc_file.write(f"*Last updated: {current_date}*\n\n")

        sorted_books = sorted(filenames.keys())
        moc_file.write("## Book Highlights\n\n")
        for book in sorted_books:
            clean_name = filenames[book]
            moc_file.write(f"[[{clean_name}]]\n")

# Process clippings
def process_clippings(config, delete_source=False):
    device_name = config.get('device_name', '')
    dest_dir = os.path.expanduser(config.get('dest_dir', ''))
    moc_filename = config.get('moc_filename', '')
    
    clippings_file_path = get_clippings_file_path(device_name)
    
    print(f"Looking for clippings at: {clippings_file_path}")
    print(f"Will save markdown files to: {dest_dir}")
    
    if not os.path.exists(clippings_file_path):
        print(f"ERROR: Clippings file not found at {clippings_file_path}")
        return False
    
    ensure_dest_dir(dest_dir)
    content = read_clippings(clippings_file_path)
    clippings = parse_clippings(content)
    
    if clippings:
        create_markdown_files(clippings, dest_dir, moc_filename)
        
        if delete_source:
            try:
                # Create a backup before deleting
                backup_path = os.path.join(dest_dir, "My_Clippings_backup.txt")
                shutil.copy2(clippings_file_path, backup_path)
                print(f"Created backup at {backup_path}")
                
                # Delete the original file
                os.remove(clippings_file_path)
                print(f"Deleted source file: {clippings_file_path}")
            except Exception as e:
                print(f"Error while trying to delete source file: {e}")
        
        print("Done! Markdown files and MOC created successfully.")
        return True
    else:
        print("No clippings found to process.")
        return False

# Main function
def main():
    parser = argparse.ArgumentParser(description='Kindle clippings to Markdown converter for Obsidian')
    parser.add_argument('--config', action='store_true', help='Configure Klippy settings')
    parser.add_argument('--add', action='store_true', help='Process clippings without deleting source file')
    parser.add_argument('--sync', action='store_true', help='Process clippings and delete source file')
    
    args = parser.parse_args()
    
    if args.config:
        setup_config()
        return
    
    config = load_config()
    
    # If no action flags are provided, show help
    if not (args.add or args.sync):
        parser.print_help()
        return
    
    # --sync takes precedence over --add if both are specified
    process_clippings(config, delete_source=args.sync)

if __name__ == "__main__":
    main()
